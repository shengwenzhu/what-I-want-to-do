# 垃圾收集-GC

> GC：Garbage Collection

**垃圾收集需要完成的三件事情：**

+ 哪些内存需要回收
  - JVM 垃圾回收重点考虑堆内存的垃圾回收
+ 什么时候回收
+ 如何回收

## 一、判断对象是否需要被回收

1. **哪些对象需要被回收**：不再被使用的对象
2. **确定不再使用的对象**：
   - 方法一：引用计数法





+ 引用计数算法（主流的虚拟机不采用该方法）

  在对象中添加一个引用计数器，有对象引用时计数器+1，引用释放时计数器-1，当计数器为0时表示该对象可以被回收，但是不保证一定被回收；

  缺点：不能解决对象之间循环引用的问题；

+ 可达性分析算法

  通过 GC Roots 作为起始节点集，根据引用关系向下搜索，搜索过程经过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，说明该对象不可达，此对象是可以被回收的；

  > **对象可回收不代表该对象一定会被回收**，垃圾回收器在回收对象内存前会先执行对象的 `finalize()` 方法，如果在这个方法中将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收。
  >
  > 哪些对象可以做为 GC Root ？
  >
  > + 虚拟机栈中引用的对象
  > + 本地方法栈中引用的对象
  > + 方法区中类静态属性引用的对象
  > + 方法区中常量引用的对象

## 2. java 引用方式

+ 强引用

  只要强引用关系存在，垃圾收集器就永远不会回收被引用的对象；

  ```java
  Object obj = new Object();
  obj = null;		// obj变量释放对对象的引用，对象将被回收
  ```

+ 软引用

  ```java
  // sf是对对象的软引用
  Object obj = new Object();
  SoftReference<Object> sf = new SoftReference<>(obj);
  // 释放obj对对象的强引用  
  obj = null;  
  sf.get();
  ```

  只被软引用关联着的对象，在系统内存空间足够时，它不会被系统回收，当系统将要发出内存溢出异常时，它才会被系统回收，如果回收还没有足够的内存空间，才会抛出内存溢出异常；

+ 弱引用

  ```java
  Object obj = new Object();  
  WeakReference<Object> wf = new WeakReference<Object>(obj);  
  obj = null;  
  wf.get(); 
  ```

  只被弱引用关联的对象只能生存到下一次垃圾收集发生为止；当垃圾收集器工作时，无论当前内存是否足够，都会回收被弱引用关联的对象；

+ 虚引用

  ```java
  Object obj = new Object();  
  PhantomReference<Object> pf = new PhantomReference<Object>(obj);  
  obj=null;  
  pf.get();//永远返回null，无法通过引用取到对象值  
  pf.isEnQueued();//返回是否从内存中已经删除   
  ```

  如果一个对象仅持有虚引用，那么它就和没有任何引用一样；

  无法通过虚引用取得对象实例；

  虚引用主要用于检测对象是否已经从内存中删除；



## 3. 垃圾回收算法

### 3.1 分代垃圾回收

**根据对象的存活周期**，将堆内存分为新生代和老年代（新生代和老年代容量占比为1：2）；将新生代分为 1个 Eden区和 2个 Survivor区，容量比例为  8:1:1；

> 为什么分代？根据对象的生存年龄，将其分配到不同的空间中存放，可以针对不同的区域设计不同的垃圾回收算法；比如对于生存年龄大的对象，将其存储到老年代，就可以使用较低的频率对这个区域进行回收；

**新生代垃圾回收过程**：大多数情况下，新生成的对象在 Eden 区分配内存空间，当 Eden 区没有空间时，将触发一次 Minor GC；如果对象在经过第一次 Minor GC 后仍然存活，并且能够被 Survivor 区容纳的话，将被移动到survivor 区中，并将对象年龄设为1；

> 如果 Survivor 无法容纳存活的对象，根据分配担保原则，对象将进入老年代；

对象在 survivor 区中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15）时，就会被晋升到老年代；

> 对象晋升到老年代的年龄阀值，可以通过选项 -XX:MaxTenuringThreshold来设置；

**老年代垃圾回收过程**：老年代存储长期存活的对象，当老年代没有空闲空间时，将触发 Full GC，垃圾回收期间会停止所有线程等待垃圾回收完成，所以对响应要求高的应用尽量减少发生Full GC；

> Minor GC：争对年轻代的垃圾回收；
>
> Major GC：争对老年代的垃圾回收，目前只有 CMS 收集器会有单独收集老年代的行为，所以Major GC 通常与 Full GC 等价；
>
> Full GC：对整个堆进行垃圾回收；



### 3.2 内存分配与回收策略

+ 对象优先在新生代 Eden 区分配

  大多数情况下，新生成的对象在 Eden 区分配内存空间，当 Eden 区没有空间时，将触发一次 Minor GC；

+ 大对象直接进入老年代

  大对象是指需要大量连续内存空间的 Java 对象；

  在分配内存空间时，大对象容易导致内存在还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象；

  如果大对象在新生代分配，当经过垃圾回收后如果对象还存活，就需要将其从 Eden 区复制到 Survivor 区，大对象意味着高额的内存复制开销；

  > 可以通过参数：-XX: PretenureSizeThreshold 设置当对象大于某个值时直接在老年代分配内存空间；

+ 长期存活对象将进入老年代

  虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头；

  大多数情况下，新生成的对象在 Eden 区分配内存空间，当 Eden 区没有空间时，将触发一次 Minor GC；如果对象在经过第一次 Minor GC 后仍然存活，并且能够被 Survivor 区容纳的话，将被移动到survivor 区中，并将对象年龄设为1；对象在 survivor 区中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15）时，就会被晋升到老年代；

+ 动态对象年龄判定

  HotSpot 虚拟机并不是永远要求对象的年龄必须达到年龄阈值才能晋升到老年代；

  如果 Survivor 区中相同年龄的对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄；

+ 空间分配担保

  当新生代 Eden 区没有空间用于分配时，将触发一次 Minor GC；

  在 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那这一次 Minor GC 可以确保是安全的；如果条件不成立，虚拟机会先查看XX：HandlePromotionFailure 参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，不过这次Minor GC是有风险的；如果小于，或者-XX： HandlePromotionFailure设置不允许担保失败，将 Minor GC 改为 Full GC；

  经过Minor GC后，如果 Survivor 区无法存储所有的存活对象，将Survivor无法容纳的对象存放到老年代中；



### 3.3 标记-清除算法

将垃圾回收过程分为两个阶段：标记阶段和清除阶段；

+ 标记阶段：标记出所有可回收的对象；
+ 清除阶段：统一回收所有被标记的对象；

**缺点：**

+ 产生内存碎片；碎片过多会导致给大对象分配内存空间时，如果找不到足够的连续内存，将会触发GC；
+ 如果存在大量对象被回收，此时必须进行大量标记和清除；



### 3.4 复制算法

将内存空间按容量划分为大小相等的两块，每次只使用其中的一块，当一块内存使用完后，将仍然存活的对象复制到另一块上，然后再把已经使用过的内存空间一次清理掉；

优点：不需要考虑内存碎片；

缺点：

+ 内存利用率低，每次只能使用其中的一半；
+ 如果存活的对象比较多，将会产生大量的内存间复制的开销；



### 3.5 标记-整理算法

将垃圾回收过程分为两个阶段：标记阶段和整理阶段；

+ 标记阶段：标记出所有可回收的对象；
+ 整理阶段：将所有存活的对象向内存空间一侧移动，然后清理掉边界以外的内存；



## 4. 垃圾收集器

用于回收新生代的收集器包括Serial、ParNew、Parallel Scavenge；

回收老年代的收集器包括Serial Old、Parallel Old、CMS；

还有用于回收整个Java堆的G1收集器；

![img](../../../../旧笔记/program_notes/docs/notes/JVM/image/垃圾回收器.png)

注：不同收集器之间的连线表示它们可以搭配使用；

+ Serial 收集器（复制算法)

  JDK 1.3 之前 hotspot 虚拟机**新生代收集器**的唯一选择；

  单线程收集器，在进行垃圾收集时，**必须暂停其他所有工作线程**，直到收集结束；

  简单高效；适用于内存受限的环境或者单核处理器或者处理器核心数较少的环境；

+ ParNew收集器 (复制算法)

  新生代收集器；

  实际上是Serial收集器的多线程版本；

+ Parallel Scavenge收集器 (复制算法)

  新生代收集器；

  特点是关注点与其他收集器不同，其他收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量；

  吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)；

  高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台运算而不需要太多交互的分析任务；

+ Serial Old收集器 (标记-整理算法)

  Serial收集器的老年代版本；

+ Parallel Old收集器 (标记-整理算法)

  Parallel Scavenge收集器的老年代版本；

### CMS收集器(Concurrent Mark Sweep)

以获取 **最短回收停顿时间** 为目标的收集器；

基于标记-清除算法实现；

将垃圾回收过程分为四个阶段：

+ 初始标记（需要暂停其他线程）

  标记 GC Roots 能直接关联到的对象；

+ 并发标记

  标记可回收的对象；

+ 重新标记（需要暂停其他线程）

  修正并发标记期间因用户程序继续执行导致标记变动的那部分对象的标记记录；

+ 并发清除

  清理标记阶段判断需要回收的对象；

  不需要停止其他线程；

缺点：

+ 基于标记-清除算法实现，所以垃圾回收结束后会产生内存碎片，空间碎片过多将会给大对象分配带来麻烦，当剩余内存不能满足分配要求时，不得不提前触发一次full GC；

+ 无法处理“浮动垃圾”，有可能出现Concurrent Mode Failure，导致触发一次full GC；

  在CMS的并发标记和并发清除阶段，用户线程还是继续运行的，在运行过程中产生的垃圾对象无法在本次垃圾回收中处理，需要等待下一次垃圾回收，这一部分垃圾称为“浮动垃圾”；

+ 对处理器资源非常敏感，垃圾回收过程会占用一部分线程；

### G1收集器 

将堆内存划分多个大小相等的独立区域，然后跟踪各个区域里的垃圾堆积价值大小（所获得空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的区域，从而保证了在有限时间内获得更高的收集效率；

基于标记-整理算法实现；

将垃圾回收过程分为四个阶段：

+ 初始标记

  标记 GC Roots 能直接关联到的对象；

+ 并发标记

  从GC Root开始标记存活对象；

+ 最终标记

  修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录；

+ 筛选回收

  对各个区域回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收；